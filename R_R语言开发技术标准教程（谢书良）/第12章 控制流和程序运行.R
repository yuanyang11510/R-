# 第12章 控制流和程序运行
# R语言是一种计算机语言，可以通过编写自己需要的函数进行编程。将操作过程的命令代码写成程序，既便于保存，也便于以后使用。

    # 12.1 函数的自定义
        # 计算直角三角形的斜边的长度
            # 函数的参数不赋予默认值
            hypotenuse <- function(x,y)
            {
                sqrt(x^2+y^2)
            } #这对大括号可以省去
            hypotenuse(3,4) #输入参数的值，输出相应的结果
            hypotenuse() #不输入参数，结果会报错
            # 一般在自定义函数中会出现return()语句，但是如果不写出return()语句，则默认返回最后一个表达式的值

            # 函数的参数赋予默认值
            hypotenuse <- function(x = 5,y = 12)
            {
                sqrt(x^2+y^2)
            }
            hypotenuse() #不输入参数，输出默认值
            hypotenuse(3,4) #输入参数的值，输出相应的结果

        # 计算向量中每一个数和所有数总和的比值
        # 将一个自定义的外层函数的参数设置为另一个自定义的内层函数
            # 方法一：先定义内层函数，再定义外层函数
            # 这种方法比较好理解
            Xfun <- function(x)
            {
                round(x*100/sum(x))
            } 
            # 先定义内层函数
            sl12_3 <- function(x,Xfun)
            {
                x.percent <- Xfun(x)
                paste(x.percent,sep = "","%")
            } 
            # 再定义外层函数，其中外层函数的参数之一为刚才定义的内层函数
            y <- c(850000,675000,925000)
            sl12_3(y,Xfun)
            # 调用外层函数

            # 方法二：先定义外层函数，再定义内层函数
            # 这种方法其实就是调换上一方法中的定义次序
            sl12_3 <- function(x,Xfun)
            {
                x.percent <- Xfun(x)
                paste(x.percent,sep = "","%")
            } 
            # 先定义外层函数，其中外层函数的参数之一为待定义的内层函数
            Xfun <- function(x)
            {
                round(x*100/sum(x))
            } 
            # 再定义内层函数
            y <- c(850000,675000,925000)
            sl12_3(y,Xfun)
            # 调用外层函数

            # 方法三：先定义外层函数，在调用外层函数的同时定义内层函数
            # 这种定义方法不太容易快速理解
            # 这是书中的定义方法，这里对其定义过程做了一些修改，删去了一些没有必要的部分
            # 删去的部分中涉及到省略号(ellipsis)的用法，可以参考：https://homerhanumat.github.io/r-notes/a-note-on-ellipses.html
            sl12_3 <- function(x,Xfun)
            {
                x.percent <- Xfun(x)
                paste(x.percent,sep = "","%")
            } 
            # 先定义外层函数，其中外层函数的参数之一为待定义的内层函数
            y <- c(850000,675000,925000)
            sl12_3(y,Xfun = function(x) round(x*100/sum(x)))
            # 在调用外层函数的同时定义内层函数
            # 注意这里定义内层函数时，省略了函数体两层的大括号
            # 注意在定义作为外层函数参数的内层函数时，必须使用“=”符号，而不能使用“<-”符号，否则会报错
            
            # 注意，下面这一方法会导致错误：在定义外层函数的同时定义内层函数
            sl12_3 <- function(x,Xfun = function(x) round(x*100/sum(x)))
            {
                x.percent <- Xfun(x)
                paste(x.percent,sep = "","%")
            }
            # 在定义外层函数的同时定义内层函数
            y <- c(850000,675000,925000)
            sl12_3(y,Xfun)
            # 调用外层函数会报错，因为其中作为参数的内层函数Xfun没有被提前存储为一个变量，导致在调用外层函数时无法调用未被存储的内层函数

            # 相比之下，按照方法一那样，从内到外依次定义好相应的函数，最后一次性调用是逻辑最清楚、最容易理解的做法
            
            # 另外关于内层函数（此处做一些修改）
            Xfun <- function(x)
            {
                round(x/sum(x),2)
            } 
            Xfun(c(1,2,3))
            Xfun(matrix(1:4,2))
            Xfun(array(1:12,c(2,3,2)))
            Xfun(data.frame(a=1:2,b=3:4))
            # 可以发现，当一个函数应用于向量/矩阵/数组/数据框（但不能是列表）时，会应用于该向量/矩阵/数组/数据框中的每一个元素并返回新的元素，最后输出的是这些新的元素组成的一个新的向量/矩阵/数组/数据框

    # 12.2 分支函数
        # 1. if-else函数
            # if()函数和else()函数
            # 判断某个年份是平年还是闰年
            # 这个涉及判断闰年的标准，书中说的不是很详细，可以参考：https://zh.wikipedia.org/wiki/%E5%85%AC%E5%8E%86#CITEREFBlegen2013、https://zhidao.baidu.com/question/617894000236613692.html
            # 简单来说，标准就是：如果年份表示的数字不能被4整除，则一定不是闰年（如2013），如果能被4整除，则再看是否能被100整除，如果不能被100整除，则一定是闰年（如2016），如果既能被4整除，又能被100整除，则再看是否能被400整除，如果能被400整除，则是闰年（如2000），如果不能被400整除，则不是闰年（如2100）
            # 其中尤其要注意，既能被4整除，又能被100整除，只是能被400整除的必要条件而不是充分条件
            sl12_4 <- function(year)
            {
                if(year %% 4 == 0 & year %% 100 != 0 | year %% 400 == 0)
                {
                    print("是闰年。")
                }
                else
                {
                    print("不是闰年。")
                }
                return(year)
            }
            new.year <- 2004
            sl12_4(new.year)
            new.year <- 2020
            sl12_4(new.year)
            new.year <- 2015
            sl12_4(new.year)
            new.year <- 2100
            sl12_4(new.year)
            new.year <- 2000
            sl12_4(new.year)

            # ifelse()函数
            ifelse(2>=3,2,3)

            # 关于if()函数、else()函数和ifelse()函数的更多特点，可以参考文件“if()、else()、ifelse()”

            # if的嵌套
            sl12_5 <- function(x)
            {
                if(x >= 90)
                {
                    print("优秀")
                }
                else if(x >= 80)
                {
                    print("良好")
                }
                else if(x >= 70)
                {
                    print("一般")
                }
                else if(x >=60)
                {
                    print("较差")
                }
                else 
                {
                    print("差")
                }
            return(x)
            }
            new.x <- 72
            sl12_5(new.x)

        # 2. switch
        # 关于switch()函数的用法介绍，可以参考：https://shixiangwang.github.io/home/cn/post/2019-11-20-r-switch/
            # 根据某人的体重和身高数据，判断属于何种体型
            sl12_6 <- function(w,h)
            {
                t <- w/h^2
                if(t <- 18)
                {
                    jr <- 1
                }
                else if(t < 25)
                {
                    jr <- 2
                }
                else if(t < 27)
                {
                    jr <- 3
                }
                else 
                {
                   jr <- 4
                }
            switch(jr,
            print("低体重体型"),
            print("正常体型"),
            print("超重体型"),
            print("肥胖体型"))
            }
            sl12_6(45,1.52)
            sl12_6(73.5,1.62)
            sl12_6(65,1,62)
            sl12_6(70,1.62)
            sl12_6(45,1.62)

        # 3. 递归函数
        # 如果一个函数自己调用自己，这个函数称为递归函数
        # 递归函数每次调用自己时，都会使问题向小的方向发展。虽然递归函数可以使程序变得很简洁，但使用时一定要特别小心
        # 必须要有一个终止条件来结束递归函数的运行，否则程序运行会陷入无休止状态
            # 用递归函数完成阶乘
            ex <- function(x)
            {
                if(x == 0)
                {
                    x_sum = 1 #这一步就是终止递归函数运行的条件
                }
                else 
                {
                   x_sum = x*ex(x-1)
                }
                return(x_sum)
            }
            ex(5)

    # 12.3 循环函数
        # 1. for函数
            # 从1开始，求n个自然数的总和
            sl12_8 <- function(n)
            {
                sumx <- 0
                for(i in n) #注意n应当是一个数值向量，否则如果只是一个数值，则i只会取该数值，而不会进行任何循环，因为不存在循环的起点和终点
                {
                    sumx <- sumx + i
                }
                print(sumx)
            }
            sl12_8(1:10)
            sl12_8(1:100)
            sl12_8(10)
            sl12_8(100)
            # 如上所述，n应当是一个数值向量，因此如果参数只输入10、100，结果只会输出10、100

        # 2. while函数
            # 找出全部“水仙花数”
            # 使用while循环搭配if()函数
            n <- 100
            Num <- c()
            while(n < 1000)
            {   
                i <- n%/%100 #百位数
                j <- n%%100%/%10 #十位数
                k <- n%%10 #个位数
                if(n == i^3 + j^3 + k^3)
                {
                    Num <- c(Num,n)
                }
                n <- n + 1
            }
            Num
            # while循环和if()函数虽然都是在条件语句的逻辑值为TRUE时执行相应命令，但是while循环会一直循环执行该命令至条件语句的逻辑值变为FALSE，而if()函数执行一次相应命令之后就会继续执行后续的命令

            # 使用for循环搭配if()函数
            Num <- c()
            for(n in 100:999)
            {
                i <- n%/%100
                j <- n%%100%/%10
                k <- n%%10
                if(n == i^3 + j^3 + k^3)
                {
                    Num <- c(Num,n)
                }
            }
            Num
            # 总的来说，还是for循环的循环区间更加清楚，因为其直接标出区间两端的数字，而while循环的循环区间则需要经过一定的计算才能够弄清楚
            # 书中的原话则是：“由此可见，for函数比while函数更简单，所以for函数应用更加广泛。”

            # 另外还可以讨论一下for循环和while循环的一些特性
            # while循环只能应用于单个元素，与其相关的if()函数（都含有条件语句）也只能应用于单个元素，因为以应用于向量为例，会导致出现多个结果
            x <- c(1:3)
            while(x <5)
            {
                print(x)
                x <- x + 1
            }

            x <- c(1:3)
            if(x < 5)
            {
                print(x)
            }
            # 结果会报错：Error in while (x > 0) { : the condition has length > 1

            # for循环的工作原理和while循环/if()函数有所不同，后者是将提前存储好的变量输入条件语句以得出相应的逻辑值，并进行相应的后续操作，而前者并不需要输入提前存储好的变量，而是在循环区间中临时设置一个变量名称作为循环变量，这一循环变量的每一个循环值都不会被存储
            x <- c(1:3)
            for(x in c(-1:2))
            {
                print(x)
            }
            # 结果依次输出数值-1、0、1、2，和提前存储好的向量(1:3)无关

        # 3. repeat函数
            # 编写一个计算100以内的Fibonacci数列的程序
            f <- c(1,1)
            i <- 1
            repeat
            {
                f[i+2] <- f[i] + f[i+1] #加入一个新元素f[i+2]，其数值是前两个元素的数值的和
                i <- i + 1 #这一步的目的是让i和i+1始终是最后两个元素的下标
                if(f[i] + f[i+1] >= 100)
                {
                    break #也可以带上括号break()
                }  
            }
            print(f)

            # 以上步骤也可以用while循环完成，因为出现了“（不）满足某一条件时终止语句，跳出循环”的工作原理
            f <- c(1,1)
            i <- 1
            while(f[i] + f[i+1] < 100)
            {
                f[i+2] <- f[i] + f[i+1]
                i <- i + 1
            }
            f
            # 这里可以看出，repeat循环实际是先进行循环，随后加上跳出循环的条件，而while循环则是预先设定继续（跳出）循环的条件，然后开始循环，两者在效果上是差不多的
            # 另外可以发现，repeat循环和while循环的优势在于可以不需要提前明确循环区间，让机器自己判断，在这一点上，for循环就失去了它的优势

    # 12.4 流程转移

    # 12.5 程序运行






