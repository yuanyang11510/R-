# 第12章 控制流和程序运行
# R语言是一种计算机语言，可以通过编写自己需要的函数进行编程。将操作过程的命令代码写成程序，既便于保存，也便于以后使用。

    # 12.1 函数的自定义
        # 计算直角三角形的斜边的长度
            # 函数的参数不赋予默认值
            hypotenuse <- function(x,y)
            {
                sqrt(x^2+y^2)
            } #*这对大括号可以省去
            hypotenuse(3,4) #输入参数的值，输出相应的结果
            hypotenuse() #不输入参数，结果会报错
            #* 一般在自定义函数中会出现return()语句，但是如果不写出return()语句，则默认返回最后一个表达式的值

            # 函数的参数赋予默认值
            hypotenuse <- function(x = 5,y = 12)
            {
                sqrt(x^2+y^2)
            }
            hypotenuse() #不输入参数，输出默认值
            hypotenuse(3,4) #输入参数的值，输出相应的结果

        # 计算向量中每一个数和所有数总和的比值
        #* 将一个自定义的外层函数的参数设置为另一个自定义的内层函数
            #* 方法一：先定义内层函数，再定义外层函数
            # 这种方法比较好理解
            Xfun <- function(x)
            {
                round(x*100/sum(x))
            } 
            # 先定义内层函数
            sl12_3 <- function(x,Xfun)
            {
                x.percent <- Xfun(x)
                paste(x.percent,sep = "","%")
            } 
            # 再定义外层函数，其中外层函数的参数之一为刚才定义的内层函数
            y <- c(850000,675000,925000)
            sl12_3(y,Xfun)
            # 调用外层函数

            #* 方法二：先定义外层函数，再定义内层函数
            # 这种方法其实就是调换上一方法中的定义次序
            sl12_3 <- function(x,Xfun)
            {
                x.percent <- Xfun(x)
                paste(x.percent,sep = "","%")
            } 
            # 先定义外层函数，其中外层函数的参数之一为待定义的内层函数
            Xfun <- function(x)
            {
                round(x*100/sum(x))
            } 
            # 再定义内层函数
            y <- c(850000,675000,925000)
            sl12_3(y,Xfun)
            # 调用外层函数

            #* 方法三：先定义外层函数，在调用外层函数的同时定义内层函数
            # 这种定义方法不太容易快速理解
            # 这是书中的定义方法，这里对其定义过程做了一些修改，删去了一些没有必要的部分
            #rfr 删去的部分中涉及到省略号(ellipsis)的用法，可以参考：https://homerhanumat.github.io/r-notes/a-note-on-ellipses.html
            sl12_3 <- function(x,Xfun)
            {
                x.percent <- Xfun(x)
                paste(x.percent,sep = "","%")
            } 
            # 先定义外层函数，其中外层函数的参数之一为待定义的内层函数
            y <- c(850000,675000,925000)
            sl12_3(y,Xfun = function(x) round(x*100/sum(x)))
            # 在调用外层函数的同时定义内层函数
            # 注意这里定义内层函数时，省略了函数体两层的大括号
            # 注意在定义作为外层函数参数的内层函数时，必须使用“=”符号，而不能使用“<-”符号，否则会报错
            
            #! 注意，下面这一方法会导致错误：在定义外层函数的同时定义内层函数
            sl12_3 <- function(x,Xfun = function(x) round(x*100/sum(x)))
            {
                x.percent <- Xfun(x)
                paste(x.percent,sep = "","%")
            }
            # 在定义外层函数的同时定义内层函数
            y <- c(850000,675000,925000)
            sl12_3(y,Xfun)
            #! 调用外层函数会报错，因为其中作为参数的内层函数Xfun没有被提前存储为一个变量，导致在调用外层函数时无法调用未被存储的内层函数

            #* 相比之下，按照方法一那样，从内到外依次定义好相应的函数，最后一次性调用是逻辑最清楚、最容易理解的做法
            
            # 另外关于内层函数（此处做一些修改）
            Xfun <- function(x)
            {
                round(x/sum(x),2)
            } 
            Xfun(c(1,2,3))
            Xfun(matrix(1:4,2))
            Xfun(array(1:12,c(2,3,2)))
            Xfun(data.frame(a=1:2,b=3:4))
            #* 可以发现，当一个函数应用于向量/矩阵/数组/数据框（但不能是列表）时，会应用于该向量/矩阵/数组/数据框中的每一个元素并返回新的元素，最后输出的是这些新的元素组成的一个新的向量/矩阵/数组/数据框，这叫做“向量化”，但其实并不是所有的函数都能够向量化，比如for循环、whhile循环等循环函数是无法向量化的

    # 12.2 分支函数
        # 1. if-else函数
            # if()函数和else()函数
            # 判断某个年份是平年还是闰年
            #rfr 这个涉及判断闰年的标准，书中说的不是很详细，可以参考：https://zh.wikipedia.org/wiki/%E5%85%AC%E5%8E%86#CITEREFBlegen2013、https://zhidao.baidu.com/question/617894000236613692.html
            # 简单来说，标准就是：如果年份表示的数字不能被4整除，则一定不是闰年（如2013），如果能被4整除，则再看是否能被100整除，如果不能被100整除，则一定是闰年（如2016），如果既能被4整除，又能被100整除，则再看是否能被400整除，如果能被400整除，则是闰年（如2000），如果不能被400整除，则不是闰年（如2100）
            #* 其中尤其要注意，既能被4整除，又能被100整除，只是能被400整除的必要条件而不是充分条件
            sl12_4 <- function(year)
            {
                if(year %% 4 == 0 && year %% 100 != 0 || year %% 400 == 0) 
                #* 注意if()函数中的条件语句（包括下文的while循环中的条件语句）中的“等于”和“不等于”要分别用"=="和"!="来表达
                #* 注意系统会提醒逻辑连接词分别用重复的"&&"和"||"表示“且”和“或”
                {
                    print("是闰年。")
                }
                else
                {
                    print("不是闰年。")
                }
                return(year)
            }
            new.year <- 2004
            sl12_4(new.year)
            new.year <- 2020
            sl12_4(new.year)
            new.year <- 2015
            sl12_4(new.year)
            new.year <- 2100
            sl12_4(new.year)
            new.year <- 2000
            sl12_4(new.year)

            # ifelse()函数
            ifelse(2>=3,2,3)

            #rfr 关于if()函数、else()函数和ifelse()函数的更多特点，可以参考文件“if()、else()、ifelse()”

            # if的嵌套
            sl12_5 <- function(x)
            {
                if(x >= 90)
                {
                    print("优秀")
                }
                else if(x >= 80)
                {
                    print("良好")
                }
                else if(x >= 70)
                {
                    print("一般")
                }
                else if(x >=60)
                {
                    print("较差")
                }
                else 
                {
                    print("差")
                }
            return(x)
            }
            new.x <- 72
            sl12_5(new.x)

        # 2. switch
        #rfr 关于switch()函数的用法介绍，可以参考：https://shixiangwang.github.io/home/cn/post/2019-11-20-r-switch/
            # 根据某人的体重和身高数据，判断属于何种体型
            sl12_6 <- function(w,h)
            {
                t <- w/h^2
                if(t <- 18)
                {
                    jr <- 1
                }
                else if(t < 25)
                {
                    jr <- 2
                }
                else if(t < 27)
                {
                    jr <- 3
                }
                else 
                {
                   jr <- 4
                }
            switch(jr,
            print("低体重体型"),
            print("正常体型"),
            print("超重体型"),
            print("肥胖体型"))
            }
            sl12_6(45,1.52)
            sl12_6(73.5,1.62)
            sl12_6(65,1,62)
            sl12_6(70,1.62)
            sl12_6(45,1.62)

        # 3. 递归函数
        # 如果一个函数自己调用自己，这个函数称为递归函数
        #! 递归函数每次调用自己时，都会使问题向小的方向发展。虽然递归函数可以使程序变得很简洁，但使用时一定要特别小心
        #! 必须要有一个终止条件来结束递归函数的运行，否则程序运行会陷入无休止状态
            # 用递归函数完成阶乘
            ex <- function(x)
            {
                if(x == 0)
                {
                    x_sum = 1 #这一步就是终止递归函数运行的条件
                }
                else 
                {
                   x_sum = x*ex(x-1)
                }
                return(x_sum)
            }
            ex(5)

    # 12.3 循环函数
        # 1. for函数
            # 从1开始，求n个自然数的总和
            sl12_8 <- function(n)
            {
                sumx <- 0
                for(i in n) #*注意n应当是一个数值向量，否则如果只是一个数值，则i只会取该数值，而不会进行任何循环，因为不存在循环的起点和终点
                {
                    sumx <- sumx + i
                }
                print(sumx)
            }
            sl12_8(1:10)
            sl12_8(1:100)
            sl12_8(10)
            sl12_8(100)
            # 如上所述，n应当是一个数值向量，因此如果参数只输入10、100，结果只会输出10、100

        # 2. while函数
            # 找出全部“水仙花数”
            # 使用while循环搭配if()函数
            n <- 100
            Num <- c()
            while(n < 1000)
            {   
                i <- n%/%100 #百位数
                j <- n%%100%/%10 #十位数
                k <- n%%10 #个位数
                if(n == i^3 + j^3 + k^3)
                {
                    Num <- c(Num,n)
                }
                n <- n + 1 #*不管是否满足条件n == i^3 + j^3 + k^3，最后都需要让n的值加一，所以不需要分别在if()条件和else()条件下重复n < n + 1的命令
            }
            Num
            #* while循环和if()函数虽然都是在条件语句的逻辑值为TRUE时执行相应命令，但是while循环会一直循环执行该命令至条件语句的逻辑值变为FALSE，而if()函数执行一次相应命令之后就会继续执行后续的命令

            # 使用for循环搭配if()函数
            Num <- c()
            for(n in 100:999)
            {
                i <- n%/%100
                j <- n%%100%/%10
                k <- n%%10
                if(n == i^3 + j^3 + k^3)
                {
                    Num <- c(Num,n)
                }
            }
            Num
            #* 总的来说，还是for循环的循环区间更加清楚，因为其直接标出区间两端的数字，而while循环的循环区间则需要经过一定的计算才能够弄清楚
            #* 书中的原话则是：“由此可见，for函数比while函数更简单，所以for函数应用更加广泛。”

            # 另外还可以讨论一下for循环和while循环的一些特性
            #* while循环只能应用于单个元素，与其相关的if()函数（都含有条件语句）也只能应用于单个元素，以应用于向量为例，结果会报错，这就是上文提到的无法“向量化”
            x <- c(1:3)
            while(x <5)
            {
                print(x)
                x <- x + 1
            }

            x <- c(1:3)
            if(x < 5)
            {
                print(x)
            }
            # 结果会报错：Error in while (x > 0) { : the condition has length > 1

            #* for循环的工作原理和while循环/if()函数有所不同，后者是将提前存储好的变量输入条件语句以得出相应的逻辑值，并进行相应的后续操作，而前者并不需要输入提前存储好的变量，而是在循环区间中临时设置一个变量名称作为循环变量，这一循环变量的每一个循环值都不会被存储
            x <- c(1:3)
            for(x in c(-1:2))
            {
                print(x)
            }
            # 结果依次输出数值-1、0、1、2，和提前存储好的向量x(1:3)无关，输出的数值-1、0、1、2也不会存储到向量x中

        # 3. repeat函数
            # 编写一个计算100以内的Fibonacci数列的程序
            f <- c(1,1)
            i <- 1
            repeat
            {
                f[i+2] <- f[i] + f[i+1] #加入一个新元素f[i+2]，其数值是前两个元素的数值的和
                i <- i + 1 #这一步的目的是让i和i+1始终是最后两个元素的下标
                if(f[i] + f[i+1] >= 100) #这一个条件其实是将斐波那契数列中大于等于100的数字排除在外
                {
                    break #也可以带上括号break()
                }  
            }
            print(f)

            # 以上步骤也可以用while循环完成，因为出现了“（不）满足某一条件时终止语句，跳出循环”的工作原理
            f <- c(1,1)
            i <- 1
            while(f[i] + f[i+1] < 100)
            {
                f[i+2] <- f[i] + f[i+1]
                i <- i + 1
            }
            f
            #* 可以发现，repeat循环实际是先设定循环，并且在循环体的最后加入跳出循环的条件，而while循环则是先设定继续（跳出）循环的条件，然后开始循环，两者在原理上是差不多的
            #* 另外可以发现，repeat循环和while循环的优势在于可以不需要提前明确循环区间，让机器自己判断，在这一点上，for循环就失去了它的优势

    # 12.4 流程转移
            # 计算1到100之间的偶数的总和
            sl12_15 <- function(n)
            {
                sumx <- 0
                for(x in n)
                {
                    if(x%%2 != 0)
                    {
                        next #也可以带上括号next() 
                        # 终止本次循环，进入下一个循环，因此可以将所有满足条件x%%2 == 0的元素筛选出来进入下一步操作
                    }
                    sumx <- sumx + x 
                }
                print(sumx)
            }
            sl12_15(1:100)

            # 将if()函数的条件改成相反的条件，就不再需要next语句，可以少写一行
            sl12_15 <- function(n)
            {
                sumx <- 0
                for(x in n)
                {
                    if(x%%2 == 0)
                    {
                        sumx <- sumx + x
                    }
                #     else 
                #     {
                #       next
                #     }
                }
                #* 以上else()函数的一部分可以省略，因为如果if()函数的条件不满足，则会默认进入下一步操作（next），具体而言，就是进行下一轮循环直至循环结束
                print(sumx)
            }
            sl12_15(1:100)

            # 由于循环区间已知，并且偶数间的间隔恒为2，因此也可以用while循环完成上述操作
            sumx <- 0
            n <- 0
            while(n <= 100)
            {
                sumx <- sumx + n
                n <- n + 2
            }
            sumx
            
    # 12.5 程序运行
            # 百鸡问题：鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一。百钱买百鸡，问鸡翁、母、雏各几何？
            # 设鸡翁有x只，鸡母有y只，鸡雏有z只，x、y、z显然都是0至100的整数，因此可以设置一个嵌套x、y、z从0至100的for循环
            Num <- data.frame()
            for(x in 0:100)
            {
                for(y in 0:100)
                {
                    for(z in 0:100)
                    {
                        if(x + y + z == 100 & 5*x + 3*y + z/3*1 == 100)
                        {
                            Num <- rbind(Num,c(x,y,z))
                        }
                    }
                }
            }
            colnames(Num) <- c("鸡翁","鸡母","鸡雏")
            Num
            #* 上述嵌套循环需要100*100*100即一百万次循环

            # 实际上，可以进一步限制x、y、z的范围：如果100元全部用来买鸡翁，则可以买20只，相应的鸡母可以买33只（余一块），鸡雏可以买300只，因此x可以限制在0至20，y可以限制在0至33，z可以限制在0至100（因为鸡翁、鸡母和鸡雏的总数只有100）
            Num <- data.frame()
            for(x in 0:20)
            {
                for(y in 0:33)
                {
                    for(z in 0:100)
                    {
                        if(x + y + z == 100 & 5*x + 3*y + z/3*1 == 100)
                        {
                            Num <- rbind(Num,c(x,y,z))
                        }
                    }
                }
            }
            colnames(Num) <- c("鸡翁","鸡母","鸡雏")
            Num
            #* 上述嵌套循环需要20*33*100即66000次循环，已经比一百万次循环少了一大半

            # 在此基础上，还可以利用上述命令中if()函数中的两个条件（即两个方程）进行消元操作，将z表示成100 - x - y，这样就不再需要z的一层循环
            Num <- data.frame()
            for(x in 0:20)
            {
                for(y in 0:33)
                {
                        if(5*x + 3*y + (100 - x - y)/3*1 == 100)
                        {
                            Num <- rbind(Num,c(x,y,100 - x - y))
                        }
                }
            }
            colnames(Num) <- c("鸡翁","鸡母","鸡雏")
            Num
            #* 上述嵌套循环只需要20*33即660次循环，可以极大地节省算力
