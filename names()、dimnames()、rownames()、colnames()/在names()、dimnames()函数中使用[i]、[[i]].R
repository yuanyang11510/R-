# 在names()、dimnames()函数中使用[i]、[[i]]

# 一、names()函数
# names()函数的作用是修改对象中的元素名称
# 在names()函数中使用索引,需要将[i]或者[[i]]放到括号的外面,表示向量/矩阵/多维数组中的第i个元素的名称，如果是在列表或者数据框的情况下,则表示第i行/列的元素/对象的名称
# 如果不在names()函数括号外面加上[i]/[[i]]索引,则会默认将相应对象的第一个元素或者第一行/列的元素/对象的名称替换为相应的值,而将其余剩下的元素/数据/对象的名称替换为缺失值NA，效果等于在names()函数括号外面加上[1]/[[1]]
# 一般说来,[i]/[[i]]只会出现在names()函数括号的外部,但是在列表或者数据框的情况下,可能会遇到需要使用[i]/[[i]]索引出列表或者数据框中第i行/列的元素/对象的需要,此时[i]/[[i]]就会同时出现在names()函数括号的内部,下面以列表为例,说明[i]/[[i]]出现在names()函数内外的各种情况

        list1 <- list(character = "apple",vector = 1:3,matrix = matrix(1:4,2,2),list = list("orange","purple"))
        list1
        list1[3] #list1[3]得到的是原列表第3行的矩阵组成的单行列表
        list1[[3]] #list1[[3]]得到的是原列表第3行的矩阵本身

    # （一）[i]/[[i]]在names()函数内部：两种情况的结果不同
        # （1）[[i]]在names()函数内部
        list1 <- list(character = "apple",vector = 1:3,matrix = matrix(1:4,2,2),list = list("orange","purple"))
        names(list1[[3]]) <- "A" 
        list1
        list1[3]
        list1[[3]]
        # 结果是将原列表中第三行的矩阵中的第一个元素命名为"A"，其他元素则默认替换为缺失值NA

        # 这一步命令实际包含了两部分:（1）用[[3]]索引出原列表中的第三行名为"matrix"的矩阵；（2）将该矩阵中的第一个元素命名为"A",而其余的元素默认被替换为缺失值NA
        # 这一步命令的第二部分实际是残缺的，因为一般会明确将矩阵中的第几个元素命名为A，这一步命令完整的形式应该是：names(list1[[3]])[1] <- "A"，[1]也可以替换成[[1]]：names(list1[[3]])[[1]]，详见下文

        # （1.1）注意：这一情况似乎并不能适用于数据框，例如以下命令：
        df.test <- data.frame(a=1:5,b=6:10,c=11:15)
        df.test
        names(df.test[3]) <- "A" 
        df.test
        df.test[3]
        df.test[[3]]
        # 可以发现，虽然没有报错，但是结果并没有呈现原数据框的第三列的第一个元素被命名为"A"，这反映出数据框中的元素应该是无法进行命名的

        # （2）[i]在names()函数内部
        list1 <- list(character = "apple",vector = 1:3,matrix = matrix(1:4,2,2),list = list("orange","purple"))
        names(list1[3]) <- "A" 
        list1
        list1[3]
        list1[[3]]
        # 结果没有变化

        # 表面上看起来，这一步命令也可以比照上一种情况，分为两部分：（1）用[3]索引出原列表中的第三行名为"matrix"的矩阵所构成的一个新的单行列表；（2）将该新列表中的第一行（也是唯一的一行）命名为"A"
        # 但是事实上第二部分的结果并没有发生，原因在于list1[3]这一索引的结果并不能用来作为表示新的单行列表的变量，而names()函数应用时，需要其中的参数代表相应的对象，因此如果再次索引list1[3]会发现结果并没有什么变化，如果确实需要修改这一新的单行矩阵的行名称，则需要先将list1[3]这一索引值赋予一个新变量，再对这个新变量运用names()函数
        # 如果要通过names()函数修改原列表第三行的矩阵的名称，需要将[3]或者[[3]]放到names()函数的外面：names(A)[3] <- "A"或者names(A)[[3]] <- "A"，详见下文

    # （二）[i]/[[i]]在names()函数外部：两种情况的结果相同
        # （1）[[i]]在names()函数外部
        list1 <- list(character = "apple",vector = 1:3,matrix = matrix(1:4,2,2),list = list("orange","purple"))
        names(list1)[[3]] <- "A"
        list1
        list1[3]
        list1[[3]]
        # 结果将列表中第3行的名称由"matrix"修改为"A"

        # （2）[i]在names()函数外部
        list1 <- list(character = "apple",vector = 1:3,matrix = matrix(1:4,2,2),list = list("orange","purple"))
        names(list1)[3] <- "A"
        list1
        list1[3]
        list1[[3]]
        # 结果将列表中第3行的名称由"matrix"修改为"A"

        # 以上两者的结果相同，说明使用names()函数时并不会区分括号外的[i]和[[i]]，其效果均是将默认将相应对象的第i个元素或者第i行/列的元素/对象的名称替换为相应的值,而将其余剩下的元素/数据/对象的名称替换为缺失值NA

# 二、dimnames()函数
# 参考：https://www.dataanalytics.org.uk/row-column-names-using-dimnames-in-r/
# dimnames()函数的作用是修改对象中的维度名称
# 注意，“维度名称”实际有两种指称，一种指的是某一维度上相应的维数所对应的名称（对应list每一行的对象内部的元素名称），另一种指的是整个维度的名称（对应list每一行的行名称），以下均是使用前者的指称，参考：https://stackoverflow.com/questions/6958041/r-apply-error-x-must-have-named-dimnames，关于维度名称和list的关系，详见下文
# 由于涉及到维度，因此适用的对象必定是有维度定义的对象，这就排除了一般的向量和列表这两个对象，而只剩下矩阵、数组(二维及以上)和数据框，下面以数据框为例说明[i]/[[i]]在dimnames()函数中的使用情况
# 注意，在dimnames()函数中，代表维度名称的参数必须以list的形式出现，并且需要完整设定每个维度的名称，不能略写，否则会报错
# 和names()函数不同,在dimnames()函数的括号外使用[[i]]并不是用于索引相应对象中的第i个/第i列元素,并且也不能使用[i],详见下文

        dataframe1 <- data.frame(a=1:5,b=6:10,c=11:15)
        dataframe1
        dataframe1[3] #dataframe1[3]得到的是原数据框第3列的元素组成的单列数据框
        dataframe1[[3]] #dataframe[[3]]得到的是原数据框第3列的元素组成的向量

    # （一）[i]/[[i]]在names()函数内部：两种情况的结果不同
        # （1）[[i]]在names()函数内部
        dataframe1 <- data.frame(a=1:5,b=6:10,c=11:15)
        dimnames(dataframe1[[3]]) <- list("A")
        # 结果会报错

        # 原因很好理解：dataframe1[[3]]索引出的是一个向量，而向量没有维度的定义，自然无法适用dimnames()函数，其性质和上文中names(list1[3]) <- "A"这一命令的情况不同，后者虽然不会报错，但是并不会造成任何结果上的变化，而此处则是在命令运行阶段直接报错，无法进行到输出结果的阶段

        # （2）[i]在names()函数内部
        dataframe1 <- data.frame(a=1:5,b=6:10,c=11:15)
        dimnames(dataframe1[3]) <- list(c(letters[1:5]),"C")
        dataframe1
        dataframe1[3]
        dataframe1[[3]]
        # 结果没有变化

        # 和上文中names(list1[3]) <- "A"这一命令的情况同理，dataframe1[3]并不能作为表示新的单列数据框的变量，如果确实需要修改这一新数据框的维度名称，则需要先将dataframe[3]这一索引值赋予一个新变量，再对这个新变量运用dimnames()函数
        # 在数据框的情况下，也可以从另一个角度想象一下：如果上述命令生效，将会在维度名称上产生冲突，即原数据框的行名称和列名称分别是1,2,3,4,5和a,b,c，而赋予新数据框的唯独名称是a,b,c,d,e和C，显然两者是无法同时成立的，造成这种数据框独有的冲突的原因有两点：（1）数据框可以通过[i]索引出新的数据框；（2）dimnames()函数对数据框的行和列名称均会进行修改。而原数据框和新数据框在列名称上是包含与被包含的关系，不会产生冲突，而在行名称上则是完全重合的，会产生冲突
        # 如果要通过dimnames()函数修改原数据框第三列的名称，需要将[[2]]放到dimnames()函数的外面，而将[2]放到dimnames()函数的外面会报错，详见下文

    # （二）[i]/[[i]]在names()函数外部：两种情况的结果不同
        # （1）[[i]]在names()函数外部
        dataframe1 <- data.frame(a=1:5,b=6:10,c=11:15)
        dimnames(dataframe1)[[2]] <- list("a","b","C")
        dataframe1
        dataframe1[3]
        dataframe1[[3]]
        # 结果将原数据框第三列的名称由"c"修改为"C"

        # 注意,此处需要再次申明使用dimnames()函数设置维度名称的几个要点：（1）关于维度名称的参数必须使用list格式；（2）维度名称必须完整设置，不能略写，比如此处虽然第1列和第2列的名称不需要修改，但也需要在设置的时候明确写出来；（3）尤其要注意,dimnames()函数括号外的[[i]]代表的是需要修改名称的维度，[[1]]代表第一维，即行，[[2]]代表第2维，即列，[[3]]代表第三维，以此类推。因此,此处的[[i]]并不是像names()函数括号外的[i]/[[i]]索引一样，代表相应对象中的第i个元素或者第i行/列的元素/对象，而是指代不同的维度，因此实际并不是一种索引
        # 至于为什么只能使用[[i]],可以从dimnames()函数给出的结果格式得到答案,比如对下面这个数据框使用dimnames()函数：
        dt.test2 <- data.frame(a=LETTERS[1:4],b=1:4)
        dt.test2
        dimnames(dt.test2)
        # 得出的结果是:
        # [[1]]
        # [1] "1" "2" "3" "4"
        # [[2]]
        # [1] "a" "b"
        # 很显然,dimnames()函数给出的结果,即相应对象的各个维度名称,是以list的形式给出的,并且分别以[[1]],[[2]],……代表行、列、第三维……，因此在用dimnames()函数设置维度名称的时候，也必须在括号外面使用[[i]]来标示需要修改的名称所属的维度，同时这也解释了为什么需要修改的维度名称必须使用list格式

        # （2）[i]在names()函数外部
        dataframe1 <- data.frame(a=1:5,b=6:10,c=11:15)
        dimnames(dataframe1)[2] <- list("a","b","C")
        # 结果会报错

        # 如上所述，在dimnames()函数的括号外面只能使用[[i]]而不能使用[i]
    
# 三、rownames()函数和colnames()函数
# 顺便还可以稍微讨论一下rownames()函数和colnames()函数，它们的作用分别是修改对象中的行名称和列名称
# 顾名思义，rownames()函数和colnames()函数适用于有行和列定义的对象，也就是矩阵（二维数组）或者数据框
# 由于维度已经确定，因此不再需要像在dimnames()函数中那样，在括号外面用[[i]]标示需要修改的名称所属的维度，下面以矩阵为例说明rownames()函数和colnames()函数的使用情况
        matrix1 <- matrix(1:4,2)
        matrix1
        rownames(matrix1) <- c("a","b")
        colnames(matrix1) <- c("c","d")
        matrix1

        # 可以发现，和dimnames()函数相比，rownames()函数和colnames()函数除了上文所说的不需要使用[[i]]标示需要修改的名称所属的维度，需要修改的维度名称也可以使用向量格式而不必须使用list格式；另外，和dimnames()函数相同的一点是，rownames()函数和colnames()函数也需要完整设置各个维度的名称，否则会报错


